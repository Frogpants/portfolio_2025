---
layout: post
title: Cool Thing I Made
---

# Dynamic Tile System

This `Tiles` class manages world tile data, graphics, collision info, and live editing.

### Tile engine source (`tiles.py`)

```python
class Tiles:
    ...
    def render_layer(self, n=1):
        self.collision_data = []
        for tile in self.tile_data:
            tx, ty = tile["x"] - cam.x, tile["y"] - cam.y
            img = self.img_data[tile["type"]]
            try:
                surface = get_image(img)
                screen.blit(surface, (int(tx), int(ty)))
            except Exception:
                pygame.draw.rect(screen, (255, 255, 255), get_rect(int(tx), int(ty)))

            if (tile["collidable"]):
                package = self.tile_package(tx, ty)
                self.collision_data.append(package)

            if (tile["interactable"]):
                package = self.tile_package(tx, ty)
                self.interact_data.append(package)
```

### Key Features

| Feature                       | Purpose                          |
| ----------------------------- | -------------------------------- |
| Camera-offset rendering       | Game world scrolls smoothly      |
| JSON-based tiles              | Saved persistent levels          |
| Collision / interaction lists | Physics & gameplay hooks         |
| Fallback drawing squares      | Debug mode + error-proof visuals |

---

## Live Tile Editor Mode

The engine includes a **real-time world builder**, toggled with ALT + E:

```python
def editor(self):
    tx, ty = snap(mouse_data.mouse_x + cam.x, 32) - cam.x, snap(mouse_data.mouse_y + cam.y, 32) - cam.y
    img = "python-game/imgs/tile4.png"
    try:
        surface = get_image(img)
        screen.blit(surface, (int(tx), int(ty)))
    except Exception:
        pygame.draw.rect(screen, (255, 255, 255), get_rect(int(tx), int(ty)))

    if mouse_data.mouse_down:
        tile_data["x"] = tx + cam.x
        tile_data["y"] = ty + cam.y
        tile_data["type"] = r.randint(0, 3)
        self.add_tile(**tile_data)
        update_json(self.json_path, self.tile_data)
```

### What it does

* Displays the tile that *would* be placed
* Snaps to 32px grid
* Places tile where mouse clicks
* Saves immediately to JSON
* Random tile types → natural variation (grass/stone/etc.)

This makes world building **as easy as painting**.

---

## Integrating With the Game Loop (`main.py`)

Now let's see how the tile system plugs into the game loop:

```python
from tiles import tile_controller
editor = False

tile_controller.add_tile()  # ensures at least one tile exists

while True:
    ...
    screen.fill((30, 30, 30))

    # draw world tiles
    tile_controller.render_layer()

    # toggle editor mode
    if (keys[pygame.K_LALT] and keys[pygame.K_e]):
        editor = True
    elif (keys[pygame.K_LALT] and keys[pygame.K_r]):
        editor = False

    if (editor):
        tile_controller.editor()
        # manual camera movement for map building
        if keys[pygame.K_a]: cam.x += -4
        if keys[pygame.K_d]: cam.x += 4
        if keys[pygame.K_w]: cam.y += -4
        if keys[pygame.K_s]: cam.y += 4
    else:
        # normal player movement + camera follow
        if keys[pygame.K_a]: dx, dy = -1, 0
        if keys[pygame.K_d]: dx, dy = 1, 0
        if keys[pygame.K_w]: dx, dy = 0, -1
        if keys[pygame.K_s]: dx, dy = 0, 1

        cam.follow(player.x, player.y)
    
    player.move(dx, 0)
    player.move(0, dy)
```

### How it works together

| Game Mode       | Behavior                                              |
| --------------- | ----------------------------------------------------- |
| **Play Mode**   | Player moves, camera follows, tiles render            |
| **Editor Mode** | Player stops, mouse paints tiles, camera moves freely |

This dual-mode approach is similar to **Dev mode in Terraria** or level-editors like **Mario Maker**.

---

## Saving Tile Data When Exiting

A safety detail:

```python
if event.type == pygame.QUIT:
    update_json("python-game/data/tiles.json", [])
    pygame.quit()
```

When the window closes, it updates tile JSON to ensure no corrupted world data.

(*Tip:* You may later want to disable clearing the file — right now it wipes it.)

---

## Visual + Camera Example

During gameplay:

* Tiles scroll with camera
* Player stays centered

During editor mode:

* Player freezes
* Camera moves freely so you can paint the world

This lets you **build giant maps without leaving the game**.

---

## Why This Architecture Works

| Concept               | Advantage                            |
| --------------------- | ------------------------------------ |
| JSON tile storage     | Moddable maps, no proprietary format |
| Runtime tile painting | Instant level creation               |
| Camera abstraction    | Code works for both editing & play   |
| Tile metadata flags   | Easy expansion (water, NPCs, etc.)   |

Creating the foundation of a **RPG world engine + world editor** in pure Python.

---

## Future Upgrades

Consider adding:

* Tile selection palette instead of random type
* Undo/Redo history
* Multi-layer tile maps (background/foreground)
* Auto-tiling terrain rules (smooth edges)
* Physics tied to `collision_data`
* Interact triggers (doors, NPCs, signs)